<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程面试汇总]]></title>
    <url>%2F2019%2F05%2F08%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E9%9D%A2%E8%AF%95%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[多线程面试题汇总1. 有T1、T2、T3三个线程，如何怎样保证T2在T1执行完后执行，T3在T2执行完后执行？使用join方法。 join方法的功能是使异步执行的线程变成同步执行。即调用线程实例的start方法后，该方法会立即返回，如果调用start方法后，需要使用一个由这个线程计算得到的值，就必须使用join方法。如果不使用join方法，就不能保证当执行到start方法后面的某条语句时，这个线程一定会执行完。而使用join方法后，直到这个线程退出，程序才会往下执行。 2.Java中的Lock接口，比起synchronized，优势在哪里？如果需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，如何实现？ Lock接口最大的优势是为读和写分别提供了锁。 读写锁ReadWriteLock拥有更加强大的功能，它可细分为读锁和解锁。 读锁可以允许多个进行读操作的线程同时进入，但不允许写进程进入；写锁只允许一个写进程进入，在这期间任何进程都不能再进入。（完全符合题目中允许多个用户读和一个用户写的条件） 要注意的是每个读写锁都有挂锁和解锁，最好将每一对挂锁和解锁操作都用try、finally来套入中间的代码，这样就会防止因异常的发生而造成死锁得情况。 下面是一个示例程序： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.util.Random;import java.util.concurrent.locks.*;public class ReadWriteLockTest &#123; public static void main(String[] args) &#123; final TheData myData=new TheData(); //这是各线程的共享数据 for(int i=0;i&lt;3;i++)&#123; //开启3个读线程 new Thread(new Runnable()&#123; @Override public void run() &#123; while(true)&#123; myData.get(); &#125; &#125; &#125;).start(); &#125; for(int i=0;i&lt;3;i++)&#123; //开启3个写线程 new Thread(new Runnable()&#123; @Override public void run() &#123; while(true)&#123; myData.put(new Random().nextInt(10000)); &#125; &#125; &#125;).start(); &#125; &#125;&#125;class TheData&#123; private Object data=null; private ReadWriteLock rwl=new ReentrantReadWriteLock(); public void get()&#123; rwl.readLock().lock(); //读锁开启，读线程均可进入 try &#123; //用try finally来防止因异常而造成的死锁 System.out.println(Thread.currentThread().getName()+&quot;is ready to read&quot;); Thread.sleep(new Random().nextInt(100)); System.out.println(Thread.currentThread().getName()+&quot;have read date&quot;+data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally&#123; rwl.readLock().unlock(); //读锁解锁 &#125; &#125; public void put(Object data)&#123; rwl.writeLock().lock(); //写锁开启，这时只有一个写线程进入 try &#123; System.out.println(Thread.currentThread().getName()+&quot;is ready to write&quot;); Thread.sleep(new Random().nextInt(100)); this.data=data; System.out.println(Thread.currentThread().getName()+&quot;have write date&quot;+data); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; finally&#123; rwl.writeLock().unlock(); //写锁解锁 &#125; &#125;&#125; 3. java中wait和sleep方法有何不同？最大的不同是在等待时wait会释放锁，而sleep一直持有锁。Wait通常被用于线程间交互，sleep通常被用于暂停执行。 其它不同有： sleep是Thread类的静态方法，wait是Object方法。 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用 sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常 4.如何用Java实现阻塞队列？首先，我们要明确阻塞队列的定义： 阻塞队列（BlockingQueue）是一个支持两个附加操作的队列。这两个附加的操作是：在队列为空时，获取元素的线程会等待队列变为非空。当队列满时，存储元素的线程会等待队列可用。 阻塞队列常用于生产者和消费者的场景，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。阻塞队列就是生产者存放元素的容器，而消费者也只从容器里拿元素。 注：有关生产者——消费者问题，可查阅维基百科网址： http://zh.wikipedia.org/wiki/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98 和百度百科网址： http://baike.baidu.com/view/10800629.htm 阻塞队列的一个简单实现： 1234567891011121314151617181920212223242526272829public class BlockingQueue &#123; private List queue = new LinkedList(); private int limit = 10; public BlockingQueue(int limit)&#123; this.limit = limit; &#125; public synchronized void enqueue(Object item)throws InterruptedException &#123; while(this.queue.size() == this.limit) &#123; wait(); &#125; if(this.queue.size() == 0) &#123; notifyAll(); &#125; this.queue.add(item); &#125; public synchronized Object dequeue() throws InterruptedException&#123; while(this.queue.size() == 0)&#123; wait(); &#125; if(this.queue.size() == this.limit)&#123; notifyAll(); &#125; return this.queue.remove(0); &#125;&#125; 在enqueue和dequeue方法内部，只有队列的大小等于上限（limit）或者下限（0）时，才调用notifyAll方法。如果队列的大小既不等于上限，也不等于下限，任何线程调用enqueue或者dequeue方法时，都不会阻塞，都能够正常的往队列中添加或者移除元素。 5.编写Java代码，解决生产者——消费者问题。生产者——消费者问题是研究多线程程序时绕不开的经典问题之一，它描述是有一块缓冲区作为仓库，生产者可以将产品放入仓库，消费者则可以从仓库中取走产品。 使用问题4中阻塞队列实现代码来解决。但此不是唯一解决方案。 解决生产者/消费者问题的方法可分为两类： 采用某种机制保护生产者和消费者之间的同步； 在生产者和消费者之间建立一个管道。 第一种方式有较高的效率，并且易于实现，代码的可控制性较好，属于常用的模式。第二种管道缓冲区不易控制，被传输数据对象不易于封装等，实用性不强。因此建议使用第一种方式来实现。 同步的核心问题在于：如何保证同一资源被多个线程并发访问时的完整性？ 常用的同步方法是采用信号或加锁机制，保证资源在任意时刻至多被一个线程访问。Java语言在多线程编程上实现了完全对象化，提供了对同步机制的良好支持。 在Java中一共有四种方法支持同步，其中前三个是同步方法，一个是管道方法。管道方法不建议使用，阻塞队列方法在问题4已有描述，现只提供前两种实现方法。 wait()/notify()方法 await()/signal()方法 BlockingQueue阻塞队列方法 PipedInputStream/PipedOutputStream 生产者类： 12345678910111213141516171819202122232425262728293031323334353637public class Producer extends Thread &#123; // 每次生产的产品数量 private int num; // 所在放置的仓库 private Storage storage; // 构造函数，设置仓库 public Producer(Storage storage) &#123; this.storage = storage; &#125; // 线程run函数 public void run() &#123; produce(num); &#125; // 调用仓库Storage的生产函数 public void produce(int num) &#123; storage.produce(num); &#125; public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public Storage getStorage() &#123; return storage; &#125; public void setStorage(Storage storage) &#123; this.storage = storage; &#125;&#125; 消费者类： 1234567891011121314151617181920212223242526272829303132333435363738public class Consumer extends Thread &#123; // 每次消费的产品数量 private int num; // 所在放置的仓库 private Storage storage; // 构造函数，设置仓库 public Consumer(Storage storage) &#123; this.storage = storage; &#125; // 线程run函数 public void run() &#123; consume(num); &#125; // 调用仓库Storage的生产函数 public void consume(int num) &#123; storage.consume(num); &#125; // get/set方法 public int getNum() &#123; return num; &#125; public void setNum(int num) &#123; this.num = num; &#125; public Storage getStorage() &#123; return storage; &#125; public void setStorage(Storage storage) &#123; this.storage = storage; &#125;&#125; 仓库类：（wait()/notify()方法） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public class Storage &#123; // 仓库最大存储量 private final int MAX_SIZE = 100; // 仓库存储的载体 private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); // 生产num个产品 public void produce(int num) &#123; // 同步代码段 synchronized (list) &#123; // 如果仓库剩余容量不足 while (list.size() + num &gt; MAX_SIZE) &#123; System.out.print(&quot;【要生产的产品数量】:&quot; + num); System.out.println(&quot; 【库存量】:&quot; + list.size() + &quot; 暂时不能执行生产任务!&quot;); try &#123; list.wait();// 由于条件不满足，生产阻塞 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 生产条件满足情况下，生产num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.add(new Object()); &#125; System.out.print(&quot;【已经生产产品数】:&quot; + num); System.out.println(&quot; 【现仓储量为】:&quot; + list.size()); list.notifyAll(); &#125; &#125; // 消费num个产品 public void consume(int num) &#123; // 同步代码段 synchronized (list) &#123; // 如果仓库存储量不足 while (list.size() &lt; num) &#123; System.out.print(&quot;【要消费的产品数量】:&quot; + num); System.out.println(&quot; 【库存量】:&quot; + list.size() + &quot; 暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，消费阻塞 list.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.remove(); &#125; System.out.print(&quot;【已经消费产品数】:&quot; + num); System.out.println(&quot; 【现仓储)量为】:&quot; + list.size()); list.notifyAll(); &#125; &#125; // get/set方法 public LinkedList&lt;Object&gt; getList() &#123; return list; &#125; public void setList(LinkedList&lt;Object&gt; list) &#123; this.list = list; &#125; public int getMAX_SIZE() &#123; return MAX_SIZE; &#125;&#125; 仓库类：（await()/signal()方法） 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697public class Storage &#123; // 仓库最大存储量 // 仓库最大存储量 private final int MAX_SIZE = 100; // 仓库存储的载体 private LinkedList&lt;Object&gt; list = new LinkedList&lt;Object&gt;(); // 锁 private final Lock lock = new ReentrantLock(); // 仓库满的条件变量 private final Condition full = lock.newCondition(); // 仓库空的条件变量 private final Condition empty = lock.newCondition(); // 生产num个产品 public void produce(int num) &#123; // 获得锁 lock.lock(); // 如果仓库剩余容量不足 while (list.size() + num &gt; MAX_SIZE) &#123; System.out.print(&quot;【要生产的产品数量】:&quot; + num); System.out.println(&quot; 【库存量】:&quot; + list.size() + &quot; 暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，生产阻塞 full.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 生产条件满足情况下，生产num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.add(new Object()); &#125; System.out.print(&quot;【已经生产产品数】:&quot; + num); System.out.println(&quot; 【现仓储量为】:&quot; + list.size()); // 唤醒其他所有线程 full.signalAll(); empty.signalAll(); // 释放锁 lock.unlock(); &#125; // 消费num个产品 public void consume(int num) &#123; // 获得锁 lock.lock(); // 如果仓库存储量不足 while (list.size() &lt; num) &#123; System.out.print(&quot;【要消费的产品数量】:&quot; + num); System.out.println(&quot; 【库存量】:&quot; + list.size() + &quot; 暂时不能执行生产任务!&quot;); try &#123; // 由于条件不满足，消费阻塞 empty.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; // 消费条件满足情况下，消费num个产品 for (int i = 1; i &lt;= num; ++i) &#123; list.remove(); &#125; System.out.print(&quot;【已经消费产品数】:&quot; + num); System.out.println(&quot; 【现仓储)量为】:&quot; + list.size()); // 唤醒其他所有线程 full.signalAll(); empty.signalAll(); // 释放锁 lock.unlock(); &#125; // set/get方法 public int getMAX_SIZE() &#123; return MAX_SIZE; &#125; public LinkedList&lt;Object&gt; getList() &#123; return list; &#125; public void setList(LinkedList&lt;Object&gt; list) &#123; this.list = list; &#125;&#125; 6. 如何解决一个用Java编写的会导致死锁的程序？Java线程死锁问题往往和一个被称之为哲学家就餐的问题相关联。 注：有关哲学家就餐的问题，可查阅维基百科网址： http://zh.wikipedia.org/wiki/%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98 和百度百科网址： http://baike.baidu.com/link?url=V-QPP4G1a1PDO1krV6GreFQSp7AQl-KhAP8WGzXw4zl7eeevz3vn07MJMf8SmXfz36CtkDQXMh8kZ36_Fwnfxq 导致死锁的根源在于不适当地运用“synchronized”关键词来管理线程对特定对象的访问。 “synchronized”关键词的作用是，确保在某个时刻只有一个线程被允许执行特定的代码块，因此，被允许执行的线程首先必须拥有对变量或对象的排他性的访问权。当线程访问对象 时，线程会给对象加锁，而这个锁导致其它也想访问同一对象的线程被阻塞，直至第一个线程释放它加在对象上的锁。由于这个原因，在使用“synchronized”关键词时，很容易出现两个线程互相等待对方做出某个动作的情形。 死锁程序例子 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Deadlocker implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public void run() &#123; System.out.println(&quot;flag=&quot; + flag); if (flag == 1) &#123; synchronized (o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o2) &#123; System.out.println(&quot;1&quot;); &#125; &#125; &#125; if (flag == 0) &#123; synchronized (o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; synchronized (o1) &#123; System.out.println(&quot;0&quot;); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; Deadlocker td1 = new Deadlocker(); Deadlocker td2 = new Deadlocker(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 说明： 1234567891011&gt; 当类的对象flag=1时（T1），先锁定O1,睡眠500毫秒，然后锁定O2；&gt;&gt; 而T1在睡眠的时候另一个flag=0的对象（T2）线程启动，先锁定O2,睡眠500毫秒，等待T1释放O1；&gt;&gt; T1睡眠结束后需要锁定O2才能继续执行，而此时O2已被T2锁定；&gt;&gt; T2睡眠结束后需要锁定O1才能继续执行，而此时O1已被T1锁定；&gt;&gt; T1、T2相互等待，都需要对方锁定的资源才能继续执行，从而死锁。&gt;&gt; 避免死锁的一个通用的经验法则是:当几个线程都要访问共享资源A、B、C时，保证使每个线程都按照同样的顺序去访问它们，比如都先访问A，再访问B和C。 如把 Thread t2 = new Thread(td2); 改成 Thread t2 = new Thread(td1); 还有一种方法是对对象进行synchronized，加大锁定的粒度，如上面的例子中使得进程锁定当前对象，而不是逐步锁定当前对象的两个子对象o1和o2。这样就在t1锁定o1之后， 即使发生休眠，当前对象仍然被t1锁定，t2不能打断t1去锁定o2，等t1休眠后再锁定o2，获取资源，执行成功。然后释放当前对象t2，接着t1继续运行。 代码如下： 123456789101112131415161718192021222324252627282930313233343536public class Deadlocker implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); public synchronized void run() &#123; System.out.println(&quot;flag=&quot; + flag); if (flag == 1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;1&quot;); &#125; if (flag == 0) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;0&quot;); &#125; &#125; public static void main(String[] args) &#123; Deadlocker td1 = new Deadlocker(); Deadlocker td2 = new Deadlocker(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 123&gt; 代码修改成public synchronized void run()&#123;..&#125;,去掉子对象锁定。对于一个成员方法加synchronized关键字，实际上是以这个成员方法所在的对象本身作为对象锁。此例中，即对td1，td2这两个Deadlocker 对象进行加锁。&gt;&gt; 第三种解决死锁的方法是使用实现Lock接口的重入锁类（ReentrantLock），代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Deadlocker implements Runnable &#123; public int flag = 1; static Object o1 = new Object(), o2 = new Object(); private final Lock lock = new ReentrantLock(); public boolean checkLock() &#123; return lock.tryLock(); &#125; public void run() &#123; if (checkLock()) &#123; try &#123; System.out.println(&quot;flag=&quot; + flag); if (flag == 1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;1&quot;); &#125; if (flag == 0) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.out.println(&quot;0&quot;); &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; Deadlocker td1 = new Deadlocker(); Deadlocker td2 = new Deadlocker(); td1.flag = 1; td2.flag = 0; Thread t1 = new Thread(td1); Thread t2 = new Thread(td2); t1.start(); t2.start(); &#125;&#125; 说明： 123&gt; 代码行lock.tryLock()是测试对象操作是否已在执行中，如果已在执行中则不再执行此对象操作，立即返回false，达到忽略对象操作的效果。&gt;&gt; 7. 什么是原子操作，Java中的原子操作是什么？所谓原子操作是指不会被线程调度机制打断的操作；这种操作一旦开始，就一直运行到结束，中间切换到另一个线程。 java中的原子操作介绍： jdk1.5的包为java.util.concurrent.atomic 这个包里面提供了一组原子类。其基本特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性。 即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像锁一样，一直等到该方法执行完成，才由JVM从等待队列中选择另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，但不会阻塞线程（synchronized 会把别的等待的线程挂，或者说只是在硬件级别上阻塞了)。 其中的类可以分成4组 AtomicBoolean，AtomicInteger，AtomicLong，AtomicReference AtomicIntegerArray，AtomicLongArray AtomicLongFieldUpdater，AtomicIntegerFieldUpdater，AtomicReferenceFieldUpdater AtomicMarkableReference，AtomicStampedReference，AtomicReferenceArray Atomic类的作用 使得让对单一数据的操作，实现了原子化 使用Atomic类构建复杂的，无需阻塞的代码 访问对2个或2个以上的atomic变量（或者对单个atomic变量进行2次或2次以上的操作）通常认为是需要同步的，以达到让这些操作能被作为一个原子单元。 AtomicBoolean , AtomicInteger, AtomicLong, AtomicReference 这四种基本类型用来处理布尔，整数，长整数，对象四种数据。 构造函数（两个构造函数） 默认的构造函数：初始化的数据分别是false，0，0，null 带参构造函数：参数为初始化的数据 set( )和get( )方法：可以原子地设定和获取atomic的数据。类似于volatile，保证数据会在主存中设置或读取 getAndSet( )方法 原子的将变量设定为新数据，同时返回先前的旧数据 其本质是get( )操作，然后做set( )操作。尽管这2个操作都是atomic，但是他们合并在一起的时候，就不是atomic。在Java的源程序的级别上，如果不依赖synchronized的机制来完成这个工作，是不可能的。只有依靠native方法才可以。 compareAndSet( ) 和weakCompareAndSet( )方法 这两个方法都是conditional modifier方法。这2个方法接受2个参数，一个是期望数据(expected)，一个是新数据(new)；如果atomic里面的数据和期望数据一致，则将新数据设定给atomic的数据，返回true，表明成功；否则就不设定，并返回false。 对于AtomicInteger、AtomicLong还提供了一些特别的方法。getAndIncrement( )、incrementAndGet( )、getAndDecrement( )、decrementAndGet ( )、addAndGet( )、getAndAdd( )以实现一些加法，减法原子操作。(注意 –i、++i不是原子操作，其中包含有3个操作步骤：第一步，读取i；第二步，加1或减1；第三步：写回内存) 例子-使用AtomicReference创建线程安全的堆栈 1234567891011121314151617181920212223242526272829303132333435public class LinkedStack&lt;T&gt; &#123; private AtomicReference&lt;Node&lt;T&gt;&gt; stacks = new AtomicReference&lt;Node&lt;T&gt;&gt;(); public T push(T e) &#123; Node&lt;T&gt; oldNode, newNode; while (true) &#123; //这里的处理非常的特别，也是必须如此的。 oldNode = stacks.get(); newNode = new Node&lt;T&gt;(e, oldNode); if (stacks.compareAndSet(oldNode, newNode)) &#123; return e; &#125; &#125; &#125; public T pop() &#123; Node&lt;T&gt; oldNode, newNode; while (true) &#123; oldNode = stacks.get(); newNode = oldNode.next; if (stacks.compareAndSet(oldNode, newNode)) &#123; return oldNode.object; &#125; &#125; &#125; private static final class Node&lt;T&gt; &#123; private T object; private Node&lt;T&gt; next; private Node(T object, Node&lt;T&gt; next) &#123; this.object = object; this.next = next; &#125; &#125;&#125; 8. Java中的volatile关键字是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？volatile在多线程中是用来同步变量的。 线程为了提高效率，将某成员变量(如A)拷贝了一份（如B），线程中对A的访问其实访问的是B。只在某些动作时才进行A和B的同步。因此存在A和B不一致的情况。 volatile就是用来避免这种情况的。volatile告诉jvm， 它所修饰的变量不保留拷贝，直接访问主内存中的（也就是上面说的A) 变量。 一个变量声明为volatile，就意味着这个变量是随时会被其他线程修改的，因此不能将它cache在线程memory中。以下例子展现了volatile的作用： 12345678910111213public class StoppableTask extends Thread &#123; private volatile boolean pleaseStop; public void run() &#123; while (!pleaseStop) &#123; // do some stuff... &#125; &#125; public void tellMeToStop() &#123; pleaseStop = true; &#125;&#125; 假如pleaseStop没有被声明为volatile，线程执行run的时候检查的是自己的副本，就不能及时得知其他线程已经调用tellMeToStop()修改了pleaseStop的值。 Volatile一般情况下不能代替sychronized，因为volatile不能保证操作的原子性，即使只是i++，实际上也是由多个原子操作组成： 1read i; inc; write i， 假如多个线程同时执行i++，volatile只能保证他们操作的i是同一块内存，但依然可能出现写入脏数据的情况。如果配合Java 5增加的atomic wrapper classes，对它们的increase之类的操作就不需要sychronized。 volatile和synchronized的不同是最容易解释清楚的。volatile是变量修饰符，而synchronized则作用于一段代码或方法；看如下三句get代码： 123456789101112131415int i1; volatile int i2; int i3; int geti1() &#123; return i1; &#125; int geti2() &#123; return i2; &#125; synchronized int geti3() &#123; return i3; &#125; 得到存储在当前线程中i1的数值。多个线程有多个i1变量拷贝，而且这些i1之间可以互不相同。换句话说，另一个线程可能已经改变了它线程内的 i1值，而这个值可以和当前线程中的i1值不相同。事实上，Java有个思想叫“主”内存区域，这里存放了变量目前的“准确值”。每个线程可以有它自己的 变量拷贝，而这个变量拷贝值可以和“主”内存区域里存放的不同。因此实际上存在一种可能：“主”内存区域里的i1值是1，线程1里的i1值是2，线程2里 的i1值是3——这在线程1和线程2都改变了它们各自的i1值，而且这个改变还没来得及传递给“主”内存区域或其他线程时就会发生。 而 geti2()得到的是“主”内存区域的i2数值。用volatile修饰后的变量不允许有不同于“主”内存区域的变量拷贝。换句话说，一个变量经 volatile修饰后在所有线程中必须是同步的；任何线程中改变了它的值，所有其他线程立即获取到了相同的值。理所当然的，volatile修饰的变量存取时比一般变量消耗的资源要多一点，因为线程有它自己的变量拷贝更为高效。 既然volatile关键字已经实现了线程间数据同步，又要 synchronized干什么呢？它们之间有两点不同。首先，synchronized获得并释放监视器——如果两个线程使用了同一个对象锁，监视器能强制保证代码块同时只被一个线程所执行——这是众所周知的事实。但是，synchronized也同步内存：事实上，synchronized在“ 主”内存区域同步整个线程的内存。因此，执行geti3()方法做了如下几步： 1.线程请求获得监视this对象的对象锁（假设未被锁，否则线程等待直到锁释放） 2.线程内存的数据被消除，从“主”内存区域中读入 3.代码块被执行 4,对于变量的任何改变现在可以安全地写到“主”内存区域中（不过geti3()方法不会改变变量值） 5.线程释放监视this对象的对象锁 因此volatile只是在线程内存和“主”内存间同步某个变量的值，而synchronized通过锁定和解锁某个监视器同步所有变量的值。显然synchronized要比volatile消耗更多资源。 9. 什么是竞争条件？如何发现和解决竞争？两个线程同步操作同一个对象，使这个对象的最终状态不明——叫做竞争条件。竞争条件可以在任何应该由程序员保证原子操作的，而又忘记使用synchronized的地方。 唯一的解决方案就是加锁。 Java有两种锁可供选择: 对象或者类(class)的锁。每一个对象或者类都有一个锁。使用synchronized关键字获取。 synchronized加到static方法上面就使用类锁，加到普通方法上面就用对象锁。除此之外synchronized还可以用于锁定关键区域块(Critical Section)。 synchronized之后要制定一个对象(锁的携带者)，并把关键区域用大括号包裹起来。synchronized(this){// critical code}。 显示构建的锁(java.util.concurrent.locks.Lock)，调用lock的lock方法锁定关键代码。 10.如何使用thread dump？如何分析Thread dump？Thread Dump是非常有用的诊断Java应用问题的工具，每一个Java虚拟机都有及时生成显示所有线程在某一点状态的thread-dump的能力。虽然各个 Java虚拟机打印输出格式上略微有一些不同，但是Thread dumps出来的信息包含线程；线程的运行状态、标识和调用的堆栈；调用的堆栈包含完整的类名，所执行的方法，如果可能的话还有源代码的行数。 SUNJVM 产生ThreadDumpSolaris OS 12&lt;ctrl&gt;-’\’ (Control-Backslash)kill -QUIT &lt;PID&gt; HP-UX/UNIX/Linux 1Kill -3 &lt;PID&gt; Windows 1直接对MSDOS窗口的程序按Ctrl-break 有些Java应用服务器是在控制台上运行，如Weblogic，为了方便获取threaddump信息，在weblogic启动的时候，会将其标准输出重定向到一个文件， 用”nohup ./startWebLogic .sh &gt; log.out &amp;“命令，执行”kill -3 &lt;pid&gt;“，Thread dump就会输出到log.out里。 Tomcat的Thread Dump会输出到命令行控制台或者logs的catalina.out文件里。为了反映线程状态的动态变化，需要接连做三次以上thread dump，每次间隔10-20s。 IBM JVM 产生Thread Dump在AIX上用IBM的JVM，内存溢出时默认地会产生javacore文件（关于cpu的）和heapdump文件(关于内存的)。 如果没有,则参照下列方法： 在server启动前设置下面环境变量（可以加在启动脚本中） 12345678910export IBM_HEAPDUMP=trueexport IBM_HEAP_DUMP=trueexport IBM_HEAPDUMP_OUTOFMEMORY=trueexport IBM_HEAPDUMPDIR=&lt;directory path&gt; 用set命令检查参数设置，确保没有设置DISABLE_JAVADUMP，然后启动server 执行kill -3 命令可以生成javacore文件和heapdump文件 拿到java thread dump后，你要做的就是查找”waiting for monitor entry”的thread，如果大量thread都在等待给同一个地址上锁（因为对于Java，一个对象只有一把锁），这说明很可能死锁发生了。比如： 1234567891011&quot;service-j2ee&quot; prio=5 tid=0x024f1c28 nid=0x125 waiting for monitor entry[62a3e000..62a3f690][27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atcom.sun.enterprise.resource.IASNonSharedResourcePool.internalGetResource(IASNonSharedResourcePool.java:625)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - waiting tolock &lt;0x965d8110&gt; (a com.sun.enterprise.resource.IASNonSharedResourcePool)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atcom.sun.enterprise.resource.IASNonSharedResourcePool.getResource(IASNonSharedResourcePool.java:520)................ 为了确定问题，常常需要在隔两分钟后再次收集一次thread dump，如果得到的输出相同，仍然是大量thread都在等待给同一个地址上锁，那么肯定是死锁了。 如何找到当前持有锁的线程是解决问题的关键。方法是搜索thread dump，查找”locked &lt;0x965d8110&gt;“， 找到持有锁的线程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: &quot;Thread-20&quot; daemon prio=5 tid=0x01394f18nid=0x109 runnable [6716f000..6716fc28][27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atjava.net.SocketInputStream.socketRead0(Native Method)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atjava.net.SocketInputStream.read(SocketInputStream.java:129)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: at oracle.net.ns.Packet.receive(Unknown Source)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.net.ns.DataPacket.receive(Unknown Source)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.net.ns.NetInputStream.getNextPacket(Unknown Source)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.net.ns.NetInputStream.read(Unknown Source)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.net.ns.NetInputStream.read(Unknown Source)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.net.ns.NetInputStream.read(Unknown Source)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.jdbc.ttc7.MAREngine.unmarshalUB1(MAREngine.java:929)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.jdbc.ttc7.MAREngine.unmarshalSB1(MAREngine.java:893)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.jdbc.ttc7.Ocommoncall.receive(Ocommoncall.java:106)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.jdbc.ttc7.TTC7Protocol.logoff(TTC7Protocol.java:396)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - locked &lt;0x954f47a0&gt; (aoracle.jdbc.ttc7.TTC7Protocol)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atoracle.jdbc.driver.OracleConnection.close(OracleConnection.java:1518)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - locked &lt;0x954f4520&gt; (aoracle.jdbc.driver.OracleConnection)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atcom.sun.enterprise.resource.JdbcUrlAllocator.destroyResource(JdbcUrlAllocator.java:122)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atcom.sun.enterprise.resource.IASNonSharedResourcePool.destroyResource(IASNonSharedResourcePool.java:872)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atcom.sun.enterprise.resource.IASNonSharedResourcePool.resizePool(IASNonSharedResourcePool.java:1086)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: - locked &lt;0x965d8110&gt; (acom.sun.enterprise.resource.IASNonSharedResourcePool)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atcom.sun.enterprise.resource.IASNonSharedResourcePool$Resizer.run(IASNonSharedResourcePool.java:1178)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atjava.util.TimerThread.mainLoop(Timer.java:432)[27/Jun/2006:10:03:08] WARNING (26140): CORE3283: stderr: atjava.util.TimerThread.run(Timer.java:382) 在这个例子里，持有锁的线程在等待Oracle返回结果，却始终等不到响应，因此发生了死锁。 如果持有锁的线程还在等待给另一个对象上锁，那么还是按上面的办法顺藤摸瓜，直到找到死锁的根源为止。 另外，在thread dump里还会经常看到这样的线程，它们是等待一个条件而主动放弃锁的线程。例如： 12345&quot;Thread-1&quot; daemon prio=5 tid=0x014e97a8 nid=0x80 in Object.wait() [68c6f000..68c6fc28]at java.lang.Object.wait(Native Method) - waiting on &lt;0x95b07178&gt; (a java.util.LinkedList)at com.iplanet.ias.util.collection.BlockingQueue.remove(BlockingQueue.java:258)- locked &lt;0x95b07178&gt; (a java.util.LinkedList) at com.iplanet.ias.util.threadpool.FastThreadPool$ThreadPoolThread.run(FastThreadPool.java:241)at java.lang.Thread.run(Thread.java:534) 有时也会需要分析这类线程，尤其是线程等待的条件。 其实，Java thread dump并不只用于分析死锁，其它Java应用运行时古怪的行为都可以用thread dump来分析。 在Java SE 5里，增加了jstack的工具，也可以获取thread dump。在Java SE 6里， 通过jconsole的图形化工具也可以方便地查找涉及object monitors 和java.util.concurrent.locks死锁。 参考文章：http://www.cnblogs.com/zhengyun_ustc/archive/2013/01/06/dumpanalysis.html 11. 为什么调用start()方法时会执行run()方法，而不能直接调用run()方法？调用start()方法时，将会创建新的线程，并且执行在run()方法里的代码。但如果直接调用 run()方法，它不会创建新的线程也不会执行调用线程的代码。 12. Java中怎样唤醒一个阻塞的线程？如果是IO阻塞，创建线程时，加一个数量的阈值，超过该值后则不再创建。或者为每个线程设置标志变量标志该线程是否已经束，三就是直接加入线程组去管理。 如果线程因为调用 wait()、sleep()、或者join()方法而导致的阻塞，你可以中断线程，并且通过抛出InterruptedException来唤醒它。 13. Java中CycliBarriar和CountdownLatch有什么区别？CountdownLatch: 一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行。 CycliBarriar: N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。 这样应该就清楚一点了，对于CountDownLatch来说，重点是那个“一个线程”, 是它在等待，而另外那N的线程在把“某个事情”做完之后可以继续等待，也可以终止。 而对于CyclicBarrier来说，重点是那N个线程，他们之间任何一个没有完成，所有的线程都必须等待。 CyclicBarrier可以多次使用，CountDownLatch只能用一次（为0后不可变） Barrier是等待指定数量线程到达再继续处理；Latch是等待指定事件变为指定状态后发生再继续处理，对于CountDown就是计数减为0的事件，但你也可以实现或使用其他Latch，就不是这个事件了… Barrier是等待指定数量任务完成，Latch是等待其他任务完成指定状态的改变再继续 14. 什么是不可变对象，它对写并发应用有什么帮助？不可变对象（英语：Immutable object）是一种对象,在被创造之后，它的状态就不可以被改变。 由于它不可更改，并发时不需要其他额外的同步保证，故相比其他的锁同步等方式的并发性能要好。 衍生问题：为什么String是不可变的？ 字符串常量池的需要 字符串常量池(String pool, String intern pool, String保留池) 是Java堆内存中一个特殊的存储区域, 当创建一个String对象时,假如此字符串值已经存在于常量池中,则不会创建一个新的对象,而是引用已经存在的对象。 如下面的代码所示,将会在堆内存中只创建一个实际String对象. 12String s1 = &quot;abcd&quot;; String s2 = &quot;abcd&quot;; 示意图如下所示: 假若字符串对象允许改变,那么将会导致各种逻辑错误,比如改变一个对象会影响到另一个独立对象. 严格来说，这种常量池的思想,是一种优化手段. 请思考: 假若代码如下所示，s1和s2还会指向同一个实际的String对象吗? 12String s1= &quot;ab&quot; + &quot;cd&quot;; String s2= &quot;abc&quot; + &quot;d&quot;; 也许这个问题违反新手的直觉, 但是考虑到现代编译器会进行常规的优化, 所以他们都会指向常量池中的同一个对象. 或者,你可以用 jd-gui 之类的工具查看一下编译后的class文件. 允许String对象缓存HashCode Java中String对象的哈希码被频繁地使用, 比如在hashMap 等容器中。 字符串不变性保证了hash码的唯一性,因此可以放心地进行缓存.这也是一种性能优化手段,意味着不必每次都去计算新的哈希码. 在String类的定义中有如下代码: 1private int hash;//用来缓存HashCode 安全性 String被许多的Java类(库)用来当做参数,例如 网络连接地址URL,文件路径path,还有反射机制所需要的String参数等, 假若String不是固定不变的,将会引起各种安全隐患。 假如有如下的代码: 1234567boolean connect(String s) &#123; if (!isSecure(s)) &#123; throw new SecurityException(); &#125; // 如果在其他地方可以修改String,那么此处就会引起各种预料不到的问题/错误 causeProblem(s);&#125; 15. 多线程环境中遇到的常见问题是什么？如何解决？多线程和并发程序中常遇到的有Memory-interface、竞争条件、死锁、活锁和饥饿。 Memory-interface（暂无资料）[X] 竞争条件见第9题 死锁见第6题 活锁和饥饿： 活锁(英文 livelock) 概念：指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。活锁有一定几率解开。而死锁（deadlock）是无法解开的。 解决：避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。 饥饿 概念：是指如果事务T1封锁了数据R,事务T2又请求封锁R，于是T2等待。T3也请求封锁R，当T1释放了R上的封锁后，系统首先批准了T3的请 求，T2仍然等待。然后T4又请求封锁R，当T3释放了R上的封锁之后，系统又批准了T4的请求……T2可能永远等待，这就是饥饿。 解决： 公平锁： 每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住Farlock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。 代码示例 公平锁类： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class FairLock &#123; private boolean isLocked = false; private Thread lockingThread = null; private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;(); public void lock() throws InterruptedException &#123; QueueObject queueObject = new QueueObject(); boolean isLockedForThisThread = true; synchronized (this) &#123; waitingThreads.add(queueObject); &#125; while (isLockedForThisThread) &#123; synchronized (this) &#123; isLockedForThisThread = isLocked || waitingThreads.get(0) != queueObject; if (!isLockedForThisThread) &#123; isLocked = true; waitingThreads.remove(queueObject); lockingThread = Thread.currentThread(); return; &#125; &#125; try &#123; queueObject.doWait(); &#125; catch (InterruptedException e) &#123; synchronized (this) &#123; waitingThreads.remove(queueObject); &#125; throw e; &#125; &#125; &#125; public synchronized void unlock() &#123; if (this.lockingThread != Thread.currentThread()) &#123; throw new IllegalMonitorStateException(&quot;Calling thread has not locked this lock&quot;); &#125; isLocked = false; lockingThread = null; if (waitingThreads.size() &gt; 0) &#123; waitingThreads.get(0).doNotify(); &#125; &#125;&#125; 队列对象类： 12345678910111213141516171819public class QueueObject &#123; private boolean isNotified = false; public synchronized void doWait() throws InterruptedException &#123; while (!isNotified) &#123; this.wait(); &#125; this.isNotified = false; &#125; public synchronized void doNotify() &#123; this.isNotified = true; this.notify(); &#125; public boolean equals(Object o) &#123; return this == o; &#125;&#125; 说明： 首先lock()方法不再声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。 FairLock新创建一个QueueObject的实例，并对每个调用lock()的线程进行入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，用以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现了FairLock公平性。 注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。还有，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用 queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在 synchronized(this)块之外，以避免被monitor嵌套锁死，所以只要没有线程在lock方法的 synchronized(this)块中执行，另外的线程都可以被解锁。 最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。 16. 在java中绿色线程和本地线程区别？绿色线程执行用户级别的线程，且一次只使用一个OS线程。 本地线程用的是OS线程系统，在每个JAVA线程中使用一个OS线程。 在执行java时，可通过使用-green或 -native标志来选择所用线程是绿色还是本地。 17. 线程与进程的区别？线程是指进程内的一个执行单元,也是进程内的可调度实体. 与进程的区别: 地址空间:进程内的一个执行单元;进程至少有一个线程;它们共享进程的地址空间;而进程有自己独立的地址空间; 资源拥有:进程是资源分配和拥有的单位,同一个进程内的线程共享进程的资源 线程是处理器调度的基本单位,但进程不是. 二者均可并发执行. 进程和线程都是由操作系统所体会的程序运行的基本单元，系统利用该基本单元实现系统对应用的并发性。进程和线程的区别在于： 简而言之,一个程序至少有一个进程,一个进程至少有一个线程。线程的划分尺度小于进程，使得多线程程序的并发性高。 另外，进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 线程在执行过程中与进程还是有区别的。每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。这就是进程和线程的重要区别。 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动,进程是系统进行资源分配和调度的一个独立单位. 线程是进程的一个实体,是CPU调度和分派的基本单位,它是比进程更小的能独立运行的基本单位.线程自己基本上不拥有系统资源,只拥有一点在运行中必不可少的资源(如程序计数器,一组寄存器和栈),但是它可与同属一个进程的其他的线程共享进程所拥有的全部资源. 一个线程可以创建和撤销另一个线程;同一个进程中的多个线程之间可以并发执行. 18. 什么是多线程中的上下文切换？操作系统管理很多进程的执行。有些进程是来自各种程序、系统和应用程序的单独进程，而某些进程来自被分解为很多进程的应用或程序。当一个进程从内核中移出， 另一个进程成为活动的，这些进程之间便发生了上下文切换。操作系统必须记录重启进程和启动新进程使之活动所需要的所有信息。这些信息被称作上下文，它描述 了进程的现有状态。当进程成为活动的，它可以继续从被抢占的位置开始执行。 当线程被抢占时，就会发生线程之间的上下文切换。如果线程属于相同的进程，它们共享相同的地址空间，因为线程包含在它们所属于的进程的地址空间内。这样，进程需要恢复的多数信息对于线程而言是不需要的。尽管进程和它的线程共享了很多内容，但最为重要的是其地址空间和资源，有些信息对于线程而言是本地且唯一 的，而线程的其他方面包含在进程的各个段的内部。 19. 死锁与活锁的区别，死锁与饥饿的区别？死锁： 是指两个或两个以上的进程在执行过程中，因争夺资源而造成的一种互相等待的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生 了死锁，这些永远在互相等待的进程称为死锁进程。 由于资源占用是互斥的，当某个进程提出申请资源后，使得有关进程在无外力协助下，永远分配不到必需的资源而无法继续运行，这就产生了一种特殊现象：死锁。 虽然进程在运行过程中，可能发生死锁，但死锁的发生也必须具备一定的条件，死锁的发生必须具备以下四个必要条件。 互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。 请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。 环路等待条件：指在发生死锁时，必然存在一个进程——资源的环形链，即进程集合{P0，P1，P2，···，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。 活锁：指事物1可以使用资源，但它让其他事物先使用资源；事物2可以使用资源，但它也让其他事物先使用资源，于是两者一直谦让，都无法使用资源。 活锁有一定几率解开。而死锁（deadlock）是无法解开的。 避免活锁的简单方法是采用先来先服务的策略。当多个事务请求封锁同一数据对象时，封锁子系统按请求封锁的先后次序对事务排队，数据对象上的锁一旦释放就批准申请队列中第一个事务获得锁。 死锁与饥饿的区别？见第15题 20. Java中用到的线程调度算法是什么？计算机通常只有一个CPU,在任意时刻只能执行一条机器指令,每个线程只有获得CPU的使用权才能执行指令. 所谓多线程的并发运行,其实是指从宏观上看,各个线程轮流获得CPU的使用权,分别执行各自的任务.在运行池中,会有多个处于就绪状态的线程在等待CPU,JAVA虚拟机的一项任务就是负责线程的调度,线程调度是指按照特定机制为多个线程分配CPU的使用权 java虚拟机采用抢占式调度模型，是指优先让可运行池中优先级高的线程占用CPU，如果可运行池中的线程优先级相同，那么就随机选择一个线程，使其占用CPU。处于运行状态的线程会一直运行，直至它不得不放弃CPU。 一个线程会因为以下原因而放弃CPU。 java虚拟机让当前线程暂时放弃CPU，转到就绪状态，使其它线程获得运行机会。 当前线程因为某些原因而进入阻塞状态 线程结束运行 需要注意的是，线程的调度不是跨平台的，它不仅仅取决于java虚拟机，还依赖于操作系统。在某些操作系统中，只要运行中的线程没有遇到阻塞，就不会放弃CPU； 在某些操作系统中，即使线程没有遇到阻塞，也会运行一段时间后放弃CPU，给其它线程运行的机会。 java的线程调度是不分时的，同时启动多个线程后，不能保证各个线程轮流获得均等的CPU时间片。 如果希望明确地让一个线程给另外一个线程运行的机会，可以采取以下办法之一。 调整各个线程的优先级 让处于运行状态的线程调用Thread.sleep()方法 让处于运行状态的线程调用Thread.yield()方法 让处于运行状态的线程调用另一个线程的join()方法 21.在Java中什么是线程调度？见上题 22. 在线程中，怎么处理不可捕捉异常？捕捉异常有两种方法。 把线程的错误捕捉到，往上抛 通过线程池工厂，把异常捕捉到，uncaughtException往log4j写错误日志 示例代码： 12345public class TestThread implements Runnable &#123; public void run() &#123; throw new RuntimeException(&quot;throwing runtimeException.....&quot;); &#125;&#125; 当线程代码抛出运行级别异常之后，线程会中断。主线程不受这个影响，不会处理这个，而且根本不能捕捉到这个异常，仍然继续执行自己的代码。 方法1）代码示例： 12345678910111213 public class TestMain &#123; public static void main(String[] args) &#123; try &#123; TestThread t = new TestThread(); ExecutorService exec = Executors.newCachedThreadPool(); Future future = exec.submit(t); exec.shutdown(); future.get();//主要是这句话起了作用，调用get()方法，异常重抛出，包装在ExecutorException &#125; catch (Exception e) &#123;//这里可以把线程的异常继续抛出去 System.out.println(&quot;Exception Throw:&quot; + e.getMessage()); &#125; &#125;&#125; 方法2）代码示例： 12345678910111213141516171819202122232425262728public class HandlerThreadFactory implements ThreadFactory &#123; public Thread newThread(Runnable runnable) &#123; Thread t = new Thread(runnable); MyUncaughtExceptionHandler myUncaughtExceptionHandler = new MyUncaughtExceptionHandler(); t.setUncaughtExceptionHandler(myUncaughtExceptionHandler); return t; &#125;&#125;public class MyUncaughtExceptionHandler implements Thread.UncaughtExceptionHandler &#123; public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(&quot;write logger here:&quot; + e); &#125;&#125;public class TestMain &#123; public static void main(String[] args) &#123; try &#123; TestThread t = new TestThread(); ExecutorService exec = Executors.newCachedThreadPool(new HandlerThreadFactory()); exec.execute(t); &#125; catch (Exception e) &#123; System.out.println(&quot;Exception Throw:&quot; + e.getMessage()); &#125; &#125;&#125; 23. 什么是线程组，为什么在Java中不推荐使用？ThreadGroup线程组表示一个线程的集合。此外，线程组也可以包含其他线程组。线程组构成一棵树，在树中，除了初始线程组外，每个线程组都有一个父线程组。 允许线程访问有关自己的线程组的信息，但是不允许它访问有关其线程组的父线程组或其他任何线程组的信息。线程组的目的就是对线程进行管理。 线程组为什么不推荐使用 节省频繁创建和销毁线程的开销，提升线程使用效率。 衍生问题：线程组和线程池的区别在哪里？ 一个线程的周期分为：创建、运行、销毁三个阶段。处理一个任务时，首先创建一个任务线程，然后执行任务，完了，销毁线程。而线程处于运行状态的时候，才是真的在处理我们交给它的任务，这个阶段才是有效运行时间。所以，我们希望花在创建和销毁线程的资源越少越好。如果不销毁线程，而这个线程又不能被其他的任务调用，那么就会出现资源的浪费。为了提高效率，减少创建和销毁线程带来时间和空间上的浪费，出现了线程池技术。这种技术是在开始就创建一定量的线程，批量处理一类任务，等待任务的到来。任务执行完毕后，线程又可以执行其他的任务。等不再需要线程的时候，就销毁。这样就省去了频繁创建和销毁线程的麻烦。 24. 为什么使用Executor框架比使用应用创建和管理线程好？大多数并发应用程序是以执行任务（task）为基本单位进行管理的。通常情况下，我们会为每个任务单独创建一个线程来执行。 这样会带来两个问题： 一，大量的线程（&gt;100）会消耗系统资源，使线程调度的开销变大，引起性能下降； 二，对于生命周期短暂的任务，频繁地创建和消亡线程并不是明智的选择。因为创建和消亡线程的开销可能会大于使用多线程带来的性能好处。 一种更加合理的使用多线程的方法是使用线程池（Thread Pool）。 java.util.concurrent 提供了一个灵活的线程池实现：Executor 框架。这个框架可以用于异步任务执行，而且支持很多不同类型的任务执行策略。它还为任务提交和任务执行之间的解耦提供了标准的方法，为使用 Runnable 描述任务提供了通用的方式。 Executor的实现还提供了对生命周期的支持和hook 函数，可以添加如统计收集、应用程序管理机制和监视器等扩展。 在线程池中执行任务线程，可以重用已存在的线程，免除创建新的线程。这样可以在处理多个任务时减少线程创建、消亡的开销。同时，在任务到达时，工作线程通常已经存在，用于创建线程的等待时间不会延迟任务的执行，因此提高了响应性。通过适当的调整线程池的大小，在得到足够多的线程以保持处理器忙碌的同时，还可以防止过多的线程相互竞争资源，导致应用程序在线程管理上耗费过多的资源。 25. 在Java中Executor和Executors的区别？Executor是接口，是用来执行 Runnable 任务的；它只定义一个方法- execute(Runnable command)；执行 Ruannable 类型的任务。 Executors是类，提供了一系列工厂方法用于创建线程池，返回的线程池都实现了ExecutorService接口。 Executors几个重要方法： callable(Runnable task)： 将 Runnable 的任务转化成 Callable 的任务 newSingleThreadExecutor()： 产生一个ExecutorService对象，这个对象只有一个线程可用来执行任务，若任务多于一个，任务将按先后顺序执行。 newCachedThreadPool()： 产生一个ExecutorService对象，这个对象带有一个线程池，线程池的大小会根据需要调整，线程执行完任务后返回线程池，供执行下一次任务使用。 newFixedThreadPool(int poolSize)： 产生一个ExecutorService对象，这个对象带有一个大小为 poolSize 的线程池，若任务数量大于 poolSize ，任务会被放在一个 queue 里顺序执行。 newSingleThreadScheduledExecutor()： 产生一个ScheduledExecutorService对象，这个对象的线程池大小为 1 ，若任务多于一个，任务将按先后顺序执行。 newScheduledThreadPool(int poolSize)： 产生一个ScheduledExecutorService对象，这个对象的线程池大小为 poolSize ，若任务数量大于 poolSize ，任务会在一个 queue 里等待执行。 26. 如何在Windows和Linux上查找哪个线程使用的CPU时间最长？其实就是找CPU占有率最高的那个线程 Windows 任务管理器里面看，如下图： Linux 可以用下面的命令将 cpu 占用率高的线程找出来: 1$ ps H -eo user,pid,ppid,tid,time,%cpu,cmd –sort=%cpu 这个命令首先指定参数’H’，显示线程相关的信息，格式输出中包含: 1user,pid,ppid,tid,time,%cpu,cmd 然后再用%cpu字段进行排序。这样就可以找到占用处理器的线程了。]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux]]></title>
    <url>%2F2019%2F04%2F30%2FLinux%2F</url>
    <content type="text"><![CDATA[1、Linux简介&#160; &#160; &#160; &#160;Linux是一套免费使用和自由传播的类Unix操作系统，是一个基于POSIX和UNIX的多用户、多任务、支持多线程和多CPU的操作系统。它能运行主要的UNIX工具软件、应用程序和网络协议。它支持32位和64位硬件。Linux继承了Unix以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统。 2、Linux特点 系统开源并且免费 对硬件要求很低 系统稳定性强 系统安全性更好 3、Linux下载 CentOS下载&#160; &#160; &#160; &#160;Ubuntu下载 4、Linux命令4.1、cd命令cd / 返回根目录cd ~ 用户主目录cd . 当前目录cd ..返回到上一级目录cd /usr/ 进入到usr目录cd – 返回上一个目录cd 返回home 4.2、目录的操作命令（增删改查）（增）命令：mkdir -p(创建多级目录) 目录名称（查）命令：ls [-al] 父目录（a看隐藏文件，l看详细信息）（查）命令：find 目录 参数&#160; &#160; &#160; &#160;示例：查找/root下的与test相关的目录(文件) find /root -name ‘test*’（改）命令：mv 目录名称 新目录名称&#160; &#160; &#160; &#160;示例：test目录下有一个oldTest目录，使用mv oldTest newTest命令修改&#160; &#160; &#160; &#160;示例：在test下将newTest目录剪切到 /usr下面，使用mv newTest /usr（改）命令：cp -r 目录名称 目录拷贝的目标位置—–r代表递归拷贝&#160; &#160; &#160; &#160;示例：将/usr下的newTest拷贝到根目录下的test中，使用cp -r /usr/newTest /test（删）命令：rm [-rf] 目录/文件/压缩包&#160; &#160; &#160; &#160;示例：删除/usr下的newTest，进入/usr下使用rm -rf newTest 4.3、文件的操作命令（增删改查）（增）命令：touch 文件名称 —– 空文件（查）命令：cat/more/less/tail 文件&#160; &#160; &#160; &#160;示例：使用cat查看/etc/sudo.conf文件，只能显示最后一屏内容&#160; &#160; &#160; &#160;示例：使用more查看/etc/sudo.conf文件，可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看&#160; &#160; &#160; &#160;示例：使用less查看/etc/sudo.conf文件，可以使用键盘上的PgUp和PgDn向上和向下翻页，q结束查看&#160; &#160; &#160; &#160;示例：使用tail -10 查看/etc/sudo.conf文件的后10行，Ctrl+C结束 tail -f a.txt 动态查看日志信息（改）命令：vim 文件(也可以创建文件)&#160; &#160; &#160; &#160;示例：编辑/test下的aaa.txt文件，使用vim aaa.txt:wq和ZZ代表写入内容并退出输入q!代表强制退出不保存 4.4、压缩文件的操作命令Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz 命令：tar -zcvf 打包压缩后的文件名 要打包压缩的文件解压缩命令命令：tar [-xvf] 压缩文件-c 创建一个新的tar文件-v 显示运行过程的信息-f 指定文件名-z 调用gzip压缩命令进行压缩-t 查看压缩文件的内容-x 解开tar文件&#160; &#160; &#160; &#160;示例：将/test下的xxx.tar.gz解压到当前目录下 tar -xvf xxx.tar.gz&#160; &#160; &#160; &#160;示例：将/test下的xxx.tar.gz解压到根目录/usr下tar -xvf xxx.tar.gz -C /usr——C代表指定解压的位置 4.5、其他命令命令：pwd 显示当前所在位置命令：grep 要搜索的字符串 要搜索的文件&#160; &#160; &#160; &#160;示例：搜索/usr/sudu.conf文件中包含字符串to的行(高亮显示：末尾加 –color) grep to /usr/sudu.conf命令：| 将前一个命令的输出作为本次目录的输入&#160; &#160; &#160; &#160;示例：查看当前系统中所有的进程中包括system字符串的进程ps -ef | grep system命令：ps -ef 查看进程命令：kill -9 进程的pid 杀死进程查看当前系统的端口使用：netstat -an 4.6、权限命令例：-rwxrwxr--文件的类型： d：代表目录 -：代表文件 l：代表链接（可以认为是window中的快捷方式）后面的9位分为3组，每3位置一组，分别代表属主的权限，与当前用户同组的用户的权限，其他用户的权限 r：代表权限是可读，r也可以用数字4表示 w：代表权限是可写，w也可以用数字2表示 x：代表权限是可执行，x也可以用数字1表示修改文件/目录的权限的命令：chmod例：chmod u=rwx,g=rw,o=r aaa.txt 或 chmod 764 aaa.txt 5、Linux软件安装5.1、JDK安装JDK安装（注意：rpm与软件相关命令 相当于window下的软件助手 管理软件） 查看当前Linux系统是否已经安装java输入 rpm -qa | grep java 卸载两个openJDK输入rpm -e --nodeps 要卸载的软件 上传jdk到linux 安装jdk运行需要的插件yum install glibc.i686（先查看是否存在） 解压jdk到/usr/local下 tar –xvf jdk-7u71-linux-i586.tar.gz –C /usr/local 配置jdk环境变量，打开/etc/profile配置文件，将下面配置拷贝进去 12345#set java environmentJAVA_HOME=/usr/local/jdk1.7.0_71 //目录要正确CLASSPATH=.:$JAVA_HOME/lib.tools.jarPATH=$JAVA_HOME/bin:$PATHexport JAVA_HOME CLASSPATH PATH 重新加载/etc/profile配置文件 source /etc/profile 5.2、Mysql安装 上传Mysql到linux 解压Mysql到/usr/local/下的mysql目录(mysql目录需要手动创建)内 在/usr/local/mysql下安装mysql安装服务器端：rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm 安装客户端：rpm -ivh MySQL-client-5.6.22-1.el6.i686.rpm 启动mysql`service mysql start` 登录mysqlmysql安装好后会生成一个临时随机密码，存储位置在/root/.mysql_secret 修改mysql的密码set password = password(&#39;root&#39;); 开启mysql的远程登录 123语法： grant [权限] on [数据库名].[表名] to [&apos;用户名&apos;]@[&apos;web服务器的ip地址&apos;] identified by [&apos;密码&apos;]; grant all on *.* to &apos;root&apos;@&apos;%&apos; identified by &apos;root&apos;; 开放Linux的对外访问的端口3306 /sbin/iptables -I INPUT -p tcp –dport 3306 -j ACCEPT /etc/rc.d/init.d/iptables save —将修改永久保存到防火墙中]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis-plus]]></title>
    <url>%2F2019%2F04%2F29%2FMybatis-plus%2F</url>
    <content type="text"><![CDATA[1、JPA思想&#160; &#160; &#160; &#160;JPA是Java Persistence API的简称，中文名Java持久层API，是JDK 5.0注解或XML描述对象－关系表的映射关系，并将运行期的实体对象持久化到数据库中。采用面向对象的方式操作数据库。 2、Mybatis-plus2.1、简介MyBatis-Plus（简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。 Mybatis-plus官网 2.2、引入jar包123456&lt;!--spring整合mybatis-plus --&gt;&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.6&lt;/version&gt;&lt;/dependency&gt; 2.3、编辑yml配置文件1234567891011121314#mybatis-plus配置mybatis-plus: #别名包 type-aliases-package: com.zoe.pojo #引入映射文件 mapper-locations: classpath:/mybatis/mappers/*.xml #开启驼峰映射 configuration: map-underscore-to-camel-case: true#日志配置logging: level: #日志级别 com.yzy.mapper: debug 2.4、实现pojo映射123456789101112@Data@Accessors(chain=true)@TableName//实现对象与表映射关系//规则:如果对象的名称与表名一致则可以省略不写public class User &#123; @TableId(type=IdType.AUTO) //定义主键 private Integer id; private String name; private Integer age; private String sex;&#125; 2.5、实现接口继承12345//使用映射框架时,ById代表根据主键操作.public interface UserMapper extends BaseMapper&lt;User&gt;&#123; &#125; 2.6、Mybatis-plus测试1234567891011121314151617@RunWith(SpringRunner.class)@SpringBootTestpublic class TestMybatis &#123; @Autowired private UserMapper userMapper; @Test public void saveUser() &#123; User user = new User(); user.setName("测试mybaitsplus") .setAge(19) .setSex("男"); int rows = userMapper.insert(user); System.out.println("入库成功!!!影响"+rows); &#125;&#125; 2.6、Mybatis-plus底层实现原理例：userMapper.insert(user); 都是通过反射机制获取数据库. 首先获取user.class类型.之后通过class获取注解. 之后获取注解后,得到表名称. 如果字段与属性映射时,使用了驼峰映射规则,则编码时必须按照驼峰映射的条件编辑.否则程序映射报错.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SpringBoot]]></title>
    <url>%2F2019%2F04%2F29%2FSpringBoot%2F</url>
    <content type="text"><![CDATA[1、传统框架弊端 配置文件特别的繁琐. 配置时标签必须匹配. Mybatis操作时,即使再简单的sql都必须自己手写. 项目启动时必须依赖繁琐的jar包.jar包冲突问题难以解决. 现在项目启动时必须依赖tomcat插件/本地tomcat服务器. 2、SpringBoot简介&#160; &#160; &#160; &#160;Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。 2.1、特点 创建独立的Spring应用程序 嵌入的Tomcat，无需部署WAR文件 简化Maven配置 自动配置Spring 提供生产就绪型功能，如指标，健康检查和外部配置 绝对没有代码生成并且对XML也没有配置要求 3、SpringBoot入门3.1、编辑主启动类12345678910@SpringBootApplication //springBoot主启动类. 主启动类所在的包路径就是包扫描的路径public class Springboot1DemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(Springboot1DemoApplication.class, args); &#125; &#125; 3.2、application.yml配置123456789101112131415#yml是有层级关系的 #1.必须注意缩进 2.key与值之间使用:号链接 注意" "空格server: port: 8091 servlet: context-path: /#可以通过yml文件实现对象属性赋值#当spring容器启动时加载该配置#如果使用user.name当做可以 会自动的获取当前计算机用户名user: id: 110 username: 疯不觉 age: 18 sex: 男# 在pojo中 用vaule("$&#123;user.id&#125;")为属性赋值 3.3、批量为属性赋值1234567&lt;!--添加属性注入依赖 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 12345678910111213@Component//@PropertySource(value="classpath:/properties/dog.properties")//表示加载任意的properties到spring容器中@ConfigurationProperties(prefix = "user")/** * 使用说明：在配置文件中查找user的前缀，之后如果属性的名称与 * key的名称一致，则利用对象的set方法进行属性赋值 */public class User &#123; private Integer uid; private String username; private Integer age; private String sex; ... 3.4、切换环境配置1234567891011#如果是多环境测试,则必须指定默认环境spring: profiles: active: dev spring: profiles: test--- #定义分割环境spring: profiles: dev #定义研发环境 3.5、tomcat热部署与Lombok插件123456789101112131415161718&lt;!--支持热部署 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;springloaded&lt;/artifactId&gt; &lt;version&gt;1.2.8.RELEASE&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--引入插件lombok 自动的set/get/构造方法插件 --&gt;&lt;!-- @Data == Getter+Setter和toString等@Accessors(chain=true) 链式加载 --&gt;&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; 3.6、SpringBoot整合mybatis1234567891011121314151617181920&lt;!--引入数据库驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--引入druid数据源 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.12&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring整合mybatis 暂时 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt; &lt;/dependency&gt; 编辑YML文件 12345678910111213141516171819202122server: port: 8091 servlet: context-path: /spring: datasource: #引入druid数据源 type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test username: root password: 123456 #整合mybatismybatis: #别名包 type-aliases-package: com.yzy.pojo #引入映射文件 mapper-locations: classpath:/mybatis/mappers/*.xml #开启驼峰映射 configuration: map-underscore-to-camel-case: true 编辑主启动类 123456789 @SpringBootApplication @MapperScan("com.yzy.mapper") //mapper接口包路径 public class SpringBootRun &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringBootRun.class, args); &#125;&#125; 编辑测试类 12345678910111213 @RunWith(SpringRunner.class) //内部已经包含了spring容器 @SpringBootTest public class TestUser &#123; @Autowired private UserService userService; @Test public void testFindAll() &#123; System.out.println(userService.findAll()); &#125;&#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库高可用]]></title>
    <url>%2F2019%2F04%2F12%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[关闭tmcat服务器 ps -ef | grep java -&gt;&gt; kill -9(强制)/15（友好）pid 1、数据库备份策略1.1、数据库冷备份概念：&#160; &#160; &#160; &#160;在固定的周期内，人为的将数据库中的数据进行备份，一般一式三份缺点： 可能会造成数据丢失 如果数据量太多，则可能会导致备份时间很长。 ps: 虽然冷备份缺点很多，但是冷备份是恢复数据的最后手段，最好使用 1.2、数据库热备份步骤： 当主库的数据发生变化时，会将更新的数据写入二进制日志文件中 从库中的IO线程会实时的监听主库的二进制日志文件，如果文件发生了变化，就会获取主库二进制文件中更新的记录，之后写入到从库的中继日志当中。 当中继日志中有数据时，从库会通过sql线程读取中继日志中的信息，之后会将数据进行同步 当上述操作完成后，主从同步完成，等待下一次同步 数据库进行主从备份时，一台主机可以配置n台从机，一般n为2—3. 1.3、数据库安装与配置安装命令：rpm -ivh ..... .rpm启动/停止/重启：service mysql start/stop/restart设定用户名和密码：mysqladmin -u root password root 1.3.1 远程连接数据库 (临时)关闭防火墙 service iptables stop 开启mysql对外访问权限 格式：GRANT ALL PRIVILEGES ON . TO ‘登录名‘@’登录ip,%为任意地址’ IDENTIFIED BY ‘登录密码’ grant all on *.* to &#39;root&#39;@&#39;%&#39; identified by &#39;root&#39;; ps: windows访问虚拟服务器 关闭Linux防火墙和开发MySQL对外访问权限，反之亦然。 1.4、实现数据库主从搭建1.4.1、修改主库二进制文件 修改配置文件：vim /etc/my.cnf 重启MySQL数据库 检查二进制日志文件是否正确—&gt;/var/lib/mysql/ —&gt;mysql-bin.000001 auto.cnf中server-uuid是数据库的唯一标识,默认情况下，如果主、从库的server-uuid或者server-id的值一样，将会导致主从复制报错中断。 1234567[root@localhost mysql]# cd /var/lib/mysql/[root@localhost mysql]# lsabcd jtdb mysql.sockauto.cnf localhost.localdomain.pid performance_schemaibdata1 mysql RPM_UPGRADE_HISTORYib_logfile0 mysql-bin.000001 RPM_UPGRADE_MARKER-LASTib_logfile1 mysql-bin.index test 添加从库二进制文件(server-id要不一致) 1.4.2、实现数据库主从挂载 检查主库的状态 SHOW MASTER STATUS 实现主从配置1234567891011121314151617181920/*挂载指令:change master to 主机IP 主机端口号 用户名 密码二进制日志文件名称 文件位置 */CHANGE MASTER TO MASTER_HOST="192.168.30.134",MASTER_PORT=3306,MASTER_USER="root",MASTER_PASSWORD="root",MASTER_LOG_FILE="mysql-bin.000001",MASTER_LOG_POS=120;#开启主从服务START SLAVE;#检查主从状态SHOW SLAVE STATUS;#如果主从同步搭建完成,测试#如果程序报错 没有2个yes 则根据日志修改 STOP SLAVE; 2、Amoeba2.1、Amoeba介绍&#160; &#160; &#160; &#160;Ameba是一个以Mysql为底层数据存储，并对应用提供Mysql协议接口的proxy。它集中的响应应用的请求，依据用户事先设置的规则，将SQL请求发送到特定的数据库上执行。基于此可以实现负载均衡、读写分离、高可用性等需求。 2.2、Amoeba的配置 Amoeba基于JDK开发，必须先安装JDK 2.2.1、编辑dbServer.xml1234&lt;!-- mysql user 定义MySQL的用户名密码 --&gt;&lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; 12345678910111213141516&lt;!--定义主库 --&gt;&lt;dbServer name="master" parent="abstractServer"&gt; &lt;factoryConfig&gt; &lt;!-- mysql ip --&gt; &lt;property name="ipAddress"&gt;192.168.30.134&lt;/property&gt; &lt;!-- 如果用户名和密码与父级配置不同，则重新配置 --&gt; &lt;/factoryConfig&gt;&lt;/dbServer&gt;&lt;!-- 定义数据库从库 --&gt;&lt;dbServer name="slave1" parent="abstractServer"&gt; &lt;factoryConfig&gt; &lt;!-- mysql ip --&gt; &lt;property name="ipAddress"&gt;192.168.30.135&lt;/property&gt; &lt;/factoryConfig&gt;&lt;/dbServer&gt; 12345678910&lt;!-- 配置读的池 --&gt;&lt;dbServer name="multiPool" virtual="true"&gt; &lt;poolConfig class="com.meidusa.amoeba.server.MultipleServerPool"&gt; &lt;!-- Load balancing strategy: 1=ROUNDROBIN , 2=WEIGHTBASED , 3=HA 轮询、权重、hash--&gt; &lt;property name="loadbalance"&gt;1&lt;/property&gt; &lt;!-- Separated by commas,such as: server1,server2,server1 配置读池 --&gt; &lt;property name="poolNames"&gt;slave1,master,slave1&lt;/property&gt; &lt;/poolConfig&gt;&lt;/dbServer&gt; 2.2.2、编辑Amoeba.xml 检查Amoeba端口号 123&lt;service name="Amoeba for Mysql" class="com.meidusa.amoeba.mysql.server.MySQLService"&gt; &lt;!-- port --&gt; &lt;property name="port"&gt;8066&lt;/property&gt; 设定用户名和密码 123456&lt;property name="authenticateProvider"&gt; &lt;bean class="com.meidusa.amoeba.mysql.server.MysqlClientAuthenticator"&gt; &lt;property name="user"&gt;root&lt;/property&gt; &lt;property name="password"&gt;root&lt;/property&gt; 添加默认项 12345678910&lt;property name="sqlFunctionFile"&gt;$&#123;amoeba.home&#125;/conf/functionMap.xml&lt;/property&gt; &lt;property name="LRUMapSize"&gt;1500&lt;/property&gt; &lt;!--默认--&gt; &lt;property name="defaultPool"&gt;master&lt;/property&gt; &lt;!-- 配置读写分离 --&gt; &lt;property name="writePool"&gt;master&lt;/property&gt; &lt;property name="readPool"&gt;multiPool&lt;/property&gt; &lt;property name="needParse"&gt;true&lt;/property&gt; 2.2.3、修改jvm.properties12345678# JVM相关的参数，包括内存配置、垃圾回收策略# amoeba要求单个线程至少217k -Xss JVM_OPTIONS="-server -Xms256m -Xmx1024m -Xss256k -XX:PermSize=16m -XX:MaxPermSize=96m"# 应用程序忽略的信号列表，以逗号分割，程序shutdown的信号为15（可用 kill -15 pid 可让程序文明的shutdown，请不要在这儿填15）IGNORE_SIGNALS=1,2 2.3、测试Amoeba 启动Amoeba./launcher 停止Amoeba./shutdown 2.3.1、负载均衡测试只有读操作才能实现负载均衡，我们现在配置的是轮询，slave1,master,slave1所以只要修改从库中的数据就能检查负载均衡是否成功 2.3.2、读写分离测试通过网页修改数据，检查从库中的数据是否同步 3、双机热备实现搭建说明:实现互为主从的结构,双向进行数据库挂载,与以上的主从配置相同 数据库同步原则：只有用户更新数据库时才会写入二进制文件，同步时的sql语句不会写入到二进制 4、MycatMycat是阿里研发的当下主流的数据库分库分表中间件. Mycat下载 Mycat下载链接 Mycat配置编辑server.xml文件定义用户信息123456789101112&lt;!--用户标签--&gt; &lt;user name="root"&gt; &lt;property name="password"&gt;root&lt;/property&gt; &lt;!--与schema.xml中的配置相同 注意数据库的大小写--&gt; &lt;property name="schemas"&gt;zoedb&lt;/property&gt; &lt;/user&gt; &lt;user name="user"&gt; &lt;property name="password"&gt;user&lt;/property&gt; &lt;property name="schemas"&gt;zoedb&lt;/property&gt; &lt;property name="readOnly"&gt;true&lt;/property&gt; &lt;/user&gt; 编辑schema.xml文件123456789101112131415161718192021222324252627282930313233343536373839404142&lt;?xml version="1.0"?&gt;&lt;!DOCTYPE mycat:schema SYSTEM "schema.dtd"&gt;&lt;mycat:schema xmlns:mycat="http://io.mycat/"&gt; &lt;!--name属性是自定义的 dataNode表示数据库的节点信息--&gt; &lt;schema name="zoedb" checkSQLschema="false" sqlMaxLimit="100" dataNode="zoedb"/&gt; &lt;!--定义节点名称/节点主机/数据名称--&gt; &lt;dataNode name="zoedb" dataHost="localhost1" database="zoedb" /&gt; &lt;!--参数介绍--&gt; &lt;!--balance 0表示所有的读操作都会发往writeHost主机 --&gt; &lt;!--1表示所有的读操作发往readHost和闲置的主节点中--&gt; &lt;!--writeType=0 所有的写操作都发往第一个writeHost主机--&gt; &lt;!--writeType=1 所有的写操作随机发往writeHost中--&gt; &lt;!--dbType 表示数据库类型 mysql/oracle--&gt; &lt;!--dbDriver="native" 固定参数 不变--&gt; &lt;!--switchType=-1 表示不自动切换, 主机宕机后不会自动切换从节点--&gt; &lt;!--switchType=1 表示会自动切换(默认值)如果第一个主节点宕机后,Mycat会进行3次心跳检测,如果3次都没有响应,则会自动切换到第二个主节点--&gt; &lt;!--并且会更新/conf/dnindex.properties文件的主节点信息 localhost1=0 表示第一个节点.该文件不要随意修改否则会出现大问题--&gt; &lt;dataHost name="localhost1" maxCon="1000" minCon="10" balance="1" writeType="0" dbType="mysql" dbDriver="native" switchType="1" slaveThreshold="100"&gt; &lt;heartbeat&gt;select 1&lt;/heartbeat&gt; &lt;!--配置第一台主机主要进行写库操作,在默认的条件下Mycat主要操作第一台主机在第一台主机中已经实现了读写分离.因为默认写操作会发往137的数据库.读的操作默认发往141.如果从节点比较忙,则主节点分担部分压力. --&gt; &lt;writeHost host="hostM1" url="192.168.138.128:3306" user="root" password="root"&gt; &lt;!--读数据库--&gt; &lt;readHost host="hostS1" url="192.168.138.129:3306" user="root" password="root" /&gt; &lt;/writeHost&gt; &lt;!--定义第二台主机 由于数据库内部已经实现了双机热备.--&gt; &lt;!--Mycat实现高可用.当第一个主机137宕机后.mycat会自动发出心跳检测.检测3次.--&gt; &lt;!--如果主机137没有给Mycat响应则判断主机死亡.则回启东第二台主机继续为用户提供服务.--&gt; &lt;!--如果137主机恢复之后则处于等待状态.如果141宕机则137再次持续为用户提供服务.--&gt; &lt;!--前提:实现双机热备.--&gt; &lt;writeHost host="hostM2" url="192.168.138.129:3306" user="root" password="root"&gt; &lt;readHost host="hostS1" url="192.168.138.128:3306" user="root" password="root" /&gt; &lt;/writeHost&gt; &lt;/dataHost&gt;&lt;/mycat:schema&gt; Mycat启动测试 例： [root@localhost bin]# ./mycat start ./mycat console 打印控制台信息 start 启动Mycat stop 停止 restart 重启 status 状态 dump 备份 PS：如果报错信息中出现utf-8报错.则是因为中文注释的问题.需要将配置文件中的中文删除即可 分库分表数据库垂直拆分概念: 按照业务需求，将不同业务的表拆分到多个数据库中原则: 如果表有关联关系.则不能拆分到不同的数据库中. 数据库水平拆分概念: 将一张表中的数据拆分到多张表中 数据库优化策略 “优化”sql语句. 尽量根据主键查询. 尽量使用单表查询. 如果进行关联操作时,尽量提早确定数据.减少笛卡尔积 表设计中如果业务复杂则可以进行反”三范式” 创建索引(原则:为频繁查询的字段创建索引.变动小的数据.) 使用缓存处理,减少数据执行次数. redis 定期进行数据转储. 分库分表 大数据量的表才是用分库分表.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>高可用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx]]></title>
    <url>%2F2019%2F04%2F10%2Fnginx%2F</url>
    <content type="text"><![CDATA[Nginx 1、Nginx介绍&#160; &#160; &#160; &#160;Nginx (engine x) 是一个高性能的HTTP和反向代理服务，也是一个IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点开发的，第一个公开版本0.1.0发布于2004年10月4日。其将源代码以类BSD许可证的形式发布，因它的稳定性、丰富的功能集、示例配置文件和低系统资源的消耗而闻名。2011年6月1日，nginx 1.0.4发布。&#160; &#160; &#160; &#160;Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。轻量级: 1.c语言开发的. 每次启动时会开启2个进程项.每个进程占用空间不到2M.并发能力强:官方数据理论值5万/秒, 实测:3万/秒核心特点:就是请求的转发.nginx是开源免费的.硬件负载均衡器:F5 2、Nginx官网 网址: http://nginx.org/en/download.html 3、Nginx的使用 每次启动Nginx会启动2个进程项.一个是主进程.一个是守护进程.主进程:主要实现反向代理/负载均衡守护进程:防止主进程意外关闭.手动关闭：先关闭守护进程(内存小的),之后关闭主进程(内存大的). 3.1、Nginx命令 如果执行nginx命令,则必须在nginx.exe所在的根目录中执行 启动: start nginx 重启: nginx –s reload 必须先启动再重启 关闭: nginx –s stop 3.2、Nginx配置文件通过server表示一个反向代理的配置(默认配置)1234567891011121314server &#123; #表示监听的端口号 一般都是80 listen 80; #表示需要拦截的域名 server_name localhost; #真实的反向代理 location / &#123; #root是关键字 表示反向代理的是一个文件夹 root html; #默认访问页面 index index.html index.htm; &#125;&#125; 配置图片服务器12345678server &#123; listen 80; server_name image.yzy.com; location / &#123; root F:/upload; &#125; &#125; 本地测试可以修改HOSTS文件 127.0.0.1 image.yzy.com 配置后台服务器,实现域名的代理 123456789server &#123; listen 80; server_name manage.yzy.com; location / &#123; proxy_pass http://localhost:8091; &#125;&#125; 搭建tomcat集群,实现负载均衡 生成N个基于spring boot的war包 启动tomcat服务器: java -jar tomcat-8091.war 12345678910111213141516171819#配置windows tomcat集群 upstream zoe &#123; server 127.0.0.1:8091; server 127.0.0.1:8092; server 127.0.0.1:8093; &#125; #配置后台服务器 实现域名的代理 server &#123; listen 80; server_name manage.zoe.com; location / &#123; proxy_pass http://zoe; #proxy_pass http://localhost:8091; #实现tomcat集群配置 名称必须一致 &#125; &#125; 4、Nginx高级4.1、负载均衡4.1.1、轮询策略 根据配置文件的顺序,依次访问服务器 4.1.2、权重策略 权重:给性能更好的服务器多分配请求.权重值越大,分担的请求数量越多. 123456#配置windows tomcat集群 策略1:轮询 策略2:权重 upstream zoe &#123; server 127.0.0.1:8091 weight=6; server 127.0.0.1:8092 weight=3; server 127.0.0.1:8093 weight=1; &#125; 4.1.3、IPHASH(了解)问题:&#160; &#160; &#160; &#160;由于tomcat服务器中的session不能共享.所以将用户信息保存到了session的做法可能会导致用户频繁登录的现象.如何解决:&#160; &#160; &#160; &#160;让用户绑定固定的服务器.用户每次访问都访问同一台tomcat服务器.如何实现:&#160; &#160; &#160; &#160;利用IP地址进行hash运算,之后将IP地址绑定指定的服务器.引出新问题: 负载不均. IP地址可能会发生变化.导致数据无法共享 如果服务器宕机,则链接该服务器的用户都发受到影响. 技术升级: 实现SSO&#160; &#160; &#160; &#160;SSO英文全称Single Sign On，单点登录。SSO是在多个应用系统中，用户只需要登录一次就可以访问所有相互信任的应用系统。它包括可以将这次主要的登录映射到其他应用中用于同一个用户的登录的机制。它是目前比较流行的企业业务整合的解决方案之一。 4.2、Nginx高可用4.2.1、down属性 如果后台服务器因为人为的因素可以设置为down,down之后nginx将不会把请求发往该机器.1234upstream zoe&#123; ... server 127.0.0.1:8091 dowm;&#125; 4.2.2、backup策略 backup表示备用机,当主服务器不能及时响应时,或者主服务器宕机时,这时备用才会生效.1234upstream zoe&#123; ... server 127.0.0.1:8091 backup;&#125; 4.2.3、Nginx健康检测Nginx高版本特性: &#160; &#160; &#160; &#160;当服务器不能响应时,nginx会自动的访问下一台服务器.直到访问成功为止.并且在短时间内不会再次访问故障机.&#160; &#160; &#160; &#160;如果在低版本中用户访问故障机时,会一直等到服务超时才会访问下一台.原理说明:&#160; &#160; &#160; &#160;当nginx访问故障机时,记录该机器的信息,之后在指定的周期内不会再次访问该故障机.直到下一个周期请求故障机.配置信息: max_fails=1 最大失败次数1次后开始实现健康检测的机制 fail_timeout=60s; 在60秒之内不会再次访问故障机. 123456789101112131415161718192021#配置windows tomcat集群 策略1:轮询 策略2:权重 策略3:iphash 优先级最高 upstream zoe &#123; #ip_hash; server 127.0.0.1:8091 max_fails=1 fail_timeout=60s; server 127.0.0.1:8092 max_fails=1 fail_timeout=60s; server 127.0.0.1:8093 max_fails=1 fail_timeout=60s; &#125; #配置后台服务器 实现域名的代理 server &#123; listen 80; server_name manage.zoe.com; location / &#123; proxy_pass http://zoe; #proxy_pass http://localhost:8091; #实现tomcat集群配置 名称必须一致 proxy_connect_timeout 2; proxy_read_timeout 2; proxy_send_timeout 2; &#125; &#125;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>高并发</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架小记]]></title>
    <url>%2F2019%2F03%2F28%2FSSM%E6%A1%86%E6%9E%B6%E5%B0%8F%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[SSM框架小记 持续更新中…… 关于使用集合的说明使用util标签引入集合时需要注意，必须使用#{id}引入文件层级只能写一级，否则文件解析异常。例如：username=rootpassword=root mybatis核心配置文件的驼峰命名规则12345&lt;settings&gt; &lt;!-- 是否开启自动驼峰命名规则（camel case）映射， 即从经典数据库列名 A_COLUMN 到经典 Java 属性名 aColumn 的类似映射。 --&gt; &lt;setting name="mapUnderscoreToCamelCase" value="true" /&gt;&lt;/settings&gt; 配置全局异常类为了更好的用户体验，不会在页面上显示500，404等错误，便需要配置全局异常类（最好定义好JsonResult[通常有state,msg,data三个属性,有传异常形参的构造方法],以便统一返回值）ps:别忘了需要包扫描到此类！123456789101112131415161718192021222324252627/**@ControllerAdvice 修饰的类一般为springmvc中的全局异常处理类，此类中可以定义一些异常处理方法*///@RestControllerAdvice ==@ControllerAdvice+@ResponseBody@ControllerAdvicepublic class GlobalExceptionHandler&#123; /** @ExceptionHandler异常处理方法 */ @ExceptionHandler(ServiceException.class) @ResponseBody pulbic JsonResult doHandleServiceException(ServiceException e)&#123; e.printStackTrace(); return new JsonResult(e); &#125; @ExceptionHandler(RuntimeException.class) @ResponseBody public JsonResult doHandleRuntimeException(RuntimeException e)&#123; e.printStackTrace(); JsonResult r=new JsonResult(); r.setMessage("底层出现了运行时错误，请稍后"); r.setState(0); return r; &#125;&#125; restful风格 Restful就是一个资源定位及资源操作的风格。不是标准也不是协议，只是一种风格。基于这个风格设计的软件可以更简洁，更有层次，更易于实现缓存等机制。 资源：互联网所有的事物都可以被抽象为资源 资源操作：使用POST、DELETE、PUT、GET，使用不同方法对资源进行操作。分别对应 添加、 删除、修改、查询。 使用RESTful操作资源http://127.0.0.1/item/1 查询,GEThttp://127.0.0.1/item 新增,POSThttp://127.0.0.1/item 更新,PUThttp://127.0.0.1/item/1 删除,DELETE 从URL上获取参数1.使用注解@RequestMapping(&quot;item/{id}&quot;)声明请求的url2.使用(@PathVariable() Integer id)获取url上的数据 拦截器拦截器类似于Servlect中的Fileter，用于对处理器进行预处理和后处理实现HandlerInterceptor接口123456789101112131415161718192021222324public class HandlerInterceptor1 implements HandlerInterceptor &#123; // controller执行后且视图返回后调用此方法 // 这里可得到执行controller时的异常信息 // 这里可记录操作日志 public void afterCompletion(...)&#123; ... &#125; // controller执行后但未返回视图前调用此方法 // 这里可在返回用户前对模型数据进行加工处理，比如这里加入公用信息以便页面显示 public void postHandle(...)&#123; ... &#125; // Controller执行前调用此方法 // 返回true表示继续执行，返回false中止执行 // 这里可以加入登录校验、权限拦截等 public boolean preHandle(...)&#123; ... return true; &#125; &#125; 1234567891011&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 所有的请求都进入拦截器 --&gt; &lt;mvc:mapping path="/**" /&gt; &lt;!-- 不拦截静态资源 --&gt; &lt;mvc:exclude-mapping path="/assets"/&gt; &lt;!-- 配置具体的拦截器 --&gt; &lt;bean class="com.yzy.common.interceptor.HandlerInterceptor1" /&gt; &lt;ref bean="handlerInterceptor1"/&gt; #另一种配置 &lt;/mvc:interceptor&gt; 总结preHandle按拦截器定义顺序调用postHandler按拦截器定义逆序调用afterCompletion按拦截器定义逆序调用 postHandler在拦截器链内所有拦截器返成功调用afterCompletion只有preHandle返回true才调用 图片上传的业务逻辑 确定url地址,确定提交的参数名称. 可以通过文件的后缀判断是否为图片类型. png|jpg|gif 通过第三方工具判断是否为恶意程序,获取图片的宽度和高度. 为了提高检索效率,分文件储存. 按照商品类型 需要解决文件存储不均衡的现象. 指定文件夹大小,例如保存满2000张图片后新创建文件夹. 不成熟 按照时间进行储存. yyyy/MM/dd/HH 365个文件夹 防止文件重名现象. 利用时间戳生成名称+加随机数3位 UUID:保证每次生成的串”都不相同” 1/存储数据 32位16进制数据 md5(盐值+随机数) 实现文件上传. 将图片信息保存到了本地磁盘中. 生成网络请求的虚拟路径.方便其他人访问.]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>java</tag>
        <tag>ssm</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具类和插件]]></title>
    <url>%2F2019%2F03%2F27%2F%E5%B7%A5%E5%85%B7%E7%B1%BB%E5%92%8C%E6%8F%92%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[工具类和插件 持续更新中…… 表单校验插件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;!-- jQuery Validation 1.14.0 --&gt;&lt;script src="/static/assets/plugins/jquery-validation/js/jquery.validate.js"&gt;&lt;/script&gt; &lt;!--自定义校验--&gt;&lt;script src="/static/assets/plugins/jquery-validation/js/additional-methods.js"&gt;&lt;/script&gt; &lt;!--国际化标准--&gt;&lt;script src="/static/assets/plugins/jquery-validation/js/localization/messages_zh.js"&gt;&lt;/script&gt; &lt;!-- 例子1 --&gt;&lt;form:input path="username" class="form-control required" placeholder="用户名" /&gt;$(function () &#123; $("#inputForm").validate(&#123; errorElement: 'span', errorClass: 'help-block', errorPlacement: function (error, element) &#123; element.parent().parent().attr("class", "form-group has-error"); error.insertAfter(element); &#125; &#125;);&#125;);&lt;!-- 例子2 写在js文件中--&gt;/**函数对象*/var Validate=function()&#123; /**初始化 相当于私有属性*/ var handlerInitValidate=function()&#123; /**手机校验规则*/ $.validator.addMethod("mobile", function (value, element) &#123; var length = value.length; var mobile = /^(((13[0-9]&#123;1&#125;)|(15[0-9]&#123;1&#125;))+\d&#123;8&#125;)$/; return this.optional(element) || (length == 11 &amp;&amp; mobile.test(value)); &#125;, "手机号码格式错误"); &#125;; /** * 表单验证 * @param formId */ var handlerValidate = function (formId) &#123; $("#" + formId).validate(&#123; errorElement: 'span', errorClass: 'help-block', errorPlacement: function (error, element) &#123; element.parent().parent().attr("class", "form-group has-error"); error.insertAfter(element); &#125; &#125;); &#125;; return &#123; /**返回初始方法 相当于类中方法,方法名为init*/ init:function()&#123; handlerInitValidate(); &#125;, /** * 表单验证 需要前端去调用 * @param formId */ validateForm: function (formId) &#123; handlerValidate(formId); &#125; &#125;&#125;();/**文档加载*/$(function()&#123; Validate.init();&#125;) 参考网站 http://www.runoob.com/jquery/jquery-plugin-validate.html iCheck 复选/单选美化插件 http://blog.funtl.com:8080/2018/06/18/appose/jQuery-iCheck/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;!-- iCheck for checkboxes and radio inputs --&gt;&lt;link rel="stylesheet" href="/static/assets/plugins/iCheck/all.css"&gt;&lt;!-- iCheck 1.0.1 --&gt;&lt;script src="/static/assets/plugins/iCheck/icheck.min.js"&gt;&lt;/script&gt;&lt;!-- 前端Script中 --&gt;&lt;script&gt;&lt;script&gt;/** App.js 放在js文件中的函数对象*/var App=function()&#123; /**私有属性 初始化iCheck*/ var handlerInitCheckbox=function()&#123; /**默认情况下 iCheck 是不生效的 需要激活*/ $('input[type="checkbox"].minimal, input[type="radio"].minimal').iCheck(&#123; checkboxClass: 'icheckbox_minimal-blue', radioClass : 'iradio_minimal-blue' &#125;); //获取表头CheckBox _masterCheckBox=$('input[type="checkbox"].minimal.icheck_master'); //获取全部CheckBox集合 _checkbox=$('input[type="checkbox"].minimal'); &#125;; /**Checkbox全选功能*/ var handlerCheckboxAll=function()&#123; _masterCheckBox.on("ifClicked",function(e)&#123; //返回true表示未选中 if(e.target.checked)&#123; _checkbox.iCheck("uncheck"); //选中状态 &#125;else&#123; _checkbox.iCheck("check"); &#125; &#125;); &#125;; return&#123; init:function()&#123; handlerInitCheckbox(); handlerCheckboxAll(); &#125; //通过方法 获取全部CheckBox集合 getCheckbox:function()&#123; return _checkbox; &#125; &#125;&#125;(); $(function()&#123; App.init(); &#125;);]]></content>
      <categories>
        <category>拓展</category>
      </categories>
      <tags>
        <tag>插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SSM框架的搭建]]></title>
    <url>%2F2019%2F03%2F22%2FSSM%E6%A1%86%E6%9E%B6%E7%9A%84%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[SSM框架的搭建 在IDEA中进行最基本的SSM框架搭建 1、pom.xml的配置添加 Junit依赖，spring依赖，mybatis依赖，mybatis-spring依赖，MySQL驱动依赖,druid连接池依赖，Servlet/JSP/JSTL，json依赖，日志依赖。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.7&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.7&lt;/maven.compiler.target&gt; &lt;spring.version&gt;4.1.3.RELEASE&lt;/spring.version&gt; &lt;mybatis.version&gt;3.5.0&lt;/mybatis.version&gt; &lt;mybatis.spring.version&gt;1.3.2&lt;/mybatis.spring.version&gt; &lt;mysql.version&gt;5.1.32&lt;/mysql.version&gt; &lt;druid.version&gt;1.1.6&lt;/druid.version&gt; &lt;jstl.version&gt;1.2&lt;/jstl.version&gt; &lt;servlet-api.version&gt;2.5&lt;/servlet-api.version&gt; &lt;jsp-api.version&gt;2.0&lt;/jsp-api.version&gt;&lt;/properties&gt;&lt;dependencies&gt; &lt;!--Junit测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--spring核心--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--这个jar文件包含对Spring对JDBC数据访问进行封装的所有类 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--aop--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 整合mybatis框架 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mysql驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- druid连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;$&#123;druid.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Servlet/JSP/JSTL --&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;$&#123;servlet-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;$&#123;jsp-api.version&#125;&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;$&#123;jstl.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--spring与junit的整合--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!--json--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.11.3&lt;/version&gt; &lt;/dependency&gt; &lt;!--日志--&gt; &lt;!--&lt;dependency&gt;--&gt; &lt;!--&lt;groupId&gt;log4j&lt;/groupId&gt;--&gt; &lt;!--&lt;artifactId&gt;log4j&lt;/artifactId&gt;--&gt; &lt;!--&lt;version&gt;1.2.17&lt;/version&gt;--&gt; &lt;!--&lt;/dependency&gt;--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.7.25&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt; &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 配置tomcat端口 --&gt; &lt;port&gt;8080&lt;/port&gt; &lt;path&gt;/&lt;path&gt; &lt;/configuration&gt; &lt;/plugin&gt; 2、创建好目录结构123456789101112131415161718src |-main |-java //Java代码包 |-com.your.contorller //控制层 |-com.your.service //业务层 |-com.your.dao /持久层 |-com.your.entity //实体类 |-com.your.common //通用类 |-resource //资源包 |-mapper //mapper.xml |-jdbc.properties //数据库配置文件 |-log4j.properties //日志配置文件 |-spring-config.xml //spring的xml配置 |-spring-mvc.xml //springMVC配置 |-test //测试包 |-webapp |-WEB-INF |-web.xml 3、jdbc.properties的配置1234db.driverClassName=com.mysql.jdbc.Driverdb.url=jdbc:mysql:///test?characterEncoding=utf-8db.username=rootdb.password=123456 4、log4j.properties的配置1234567log4j.rootLogger=INFO,stdoutlog4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%d [%-5p] %c - %m%nlog4j.logger.com.mybatis3=DEBUGlog4j.logger.com.db.sys=DEBUG 5、*mapper.xml的头文件1234567&lt;?xml version="1.0" encoding="UTF-8" ?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper &gt;&lt;/mapper&gt; 6、spring-config.xml的配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beanshttp://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsdhttp://www.springframework.org/schema/aophttp://www.springframework.org/schema/aop/spring-aop.xsdhttp://www.springframework.org/schema/txhttp://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--扫描com.zoe下的所有注解--&gt; &lt;context:component-scan base-package="com.zoe"/&gt; &lt;!--配置数据库--&gt; &lt;context:property-placeholder location="classpath:jdbc.properties"/&gt; &lt;!--配置数据源--&gt; &lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource"&gt; &lt;property name="driverClassName" value="$&#123;db.driverClassName&#125;"/&gt; &lt;property name="url" value="$&#123;db.url&#125;"/&gt; &lt;property name="username" value="$&#123;db.username&#125;"/&gt; &lt;property name="password" value="$&#123;db.password&#125;"/&gt; &lt;/bean&gt; &lt;!--配置sqlsessionfactory对象--&gt; &lt;bean class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;property name="typeAliasesPackage" value="com.zoe.entity"/&gt; &lt;property name="mapperLocations" value="classpath:mapper/*Mapper.xml"/&gt; &lt;/bean&gt; &lt;!--配置扫描Dao接口包，动态实现Dao接口，注入到spring容器中--&gt; &lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="com.zoe.dao"/&gt; &lt;/bean&gt; &lt;!--使用注解实现aop--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--配置基于注解的声明式事务--&gt; &lt;tx:annotation-driven/&gt;&lt;/beans&gt; 7、spring-mvc.xml的配置123456789101112131415161718192021222324&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:p="http://www.springframework.org/schema/p" xmlns:context="http://www.springframework.org/schema/context" xmlns:mvc="http://www.springframework.org/schema/mvc" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd"&gt; &lt;!--开启SpringMVC注解模式--&gt; &lt;mvc:annotation-driven/&gt; &lt;!--静态资源默认servlet配置--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--配置视图解析器--&gt; &lt;bean class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages"/&gt; &lt;property name="suffix" value=".html"/&gt; &lt;/bean&gt;&lt;/beans&gt; 8、web.xml配置12345678910111213141516171819202122232425262728293031&lt;!-- 编码过滤器 --&gt;&lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;!-- 配置DispatcherServlet --&gt;&lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置springMVC需要加载的配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-*.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;!--&lt;async-supported&gt;true&lt;/async-supported&gt;--&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 匹配所有请求，此处也可以配置成 *.do 形式 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Markdown基本用法]]></title>
    <url>%2F2019%2F03%2F20%2FMarkdown%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[Markdown基本用法 一、标题123# 这是一级标题## 这是二级标题### 这是三级标题 二、字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 三、引用在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;n个…12&gt;这是引用的内容&gt;&gt;这是引用的内容 效果： 这是引用的内容 四、分割线三个或者三个以上的 - 或者 *1234-------******** 五、图片1234![图片alt](图片地址 &apos;&apos;图片title&apos;&apos;)图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 六、超链接1[超链接名](超链接地址 &quot;超链接title&quot;) 七、列表 无序列表 123- 列表内容+ 列表内容* 列表内容 有序列表 1231. 列表内容2. 列表内容3. 列表内容 列表嵌套 上一级和下一级之间敲三个空格即可 八、表格12345678910表头|表头|表头---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右 效果： 姓名 年龄 张某 25 韩某 18 邱某 20 九、代码1234`代码` //单行代码（```) 多行代码 //多行代码 (```) 十、首行缩进1&amp;#160; &amp;#160; &amp;#160; &amp;#160;]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>补充</tag>
        <tag>用法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo的使用]]></title>
    <url>%2F2019%2F03%2F20%2Fhexo%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Hexo的搭建 张某的博客 Hexo常用命令123456789hexo n "文章名称" #新建文章，被放在\source\_posts目录下hexo n page "页面名称" #新建页面hexo g #生成静态页面至public目录hexo s #开启预览访问 http://localhost:4000 如果访问失败，可能是端口被占用hexo d #部署到GitHubhexo clean #清除缓存文件 (db.json) 和已生成的静态文件 (public)hexo s -g #生成并本地预览hexo d -g #生成并上传]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>补充知识</tag>
        <tag>工具的用法</tag>
      </tags>
  </entry>
</search>
